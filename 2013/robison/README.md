# Most poetic use of strings

Arch D. Robison<br>
<arch.d.robison@gmail.com>

## To build:

```sh
make
```

## To run:

```sh
./robison
```

## Try:

```sh
echo '1*2*3*4*5*6*7*8*9%1000' | ./robison
echo '100000000000000000000*(20*(1+(99477941840441*50)))/31664812345028528' | ./robison
```

## Judges' remarks:

Of integers this prog does a lot,  
plus minus, div times (and what not).

And modulus if remainders the needing,  
on standard input percent be feeding.

More than one line can thru give input,  
when interactive one values more than throughput.

With cut and paste and some time,  
one can compute M(23209).

## Author's remarks:

### Oh, The Strings You Can C!

I love the C language; its terseness is tops.  
But the thing I abhor is numerical ops!

No shifting, division, remainder, or times.  
No increment, decrement, or subscripting blech,  
No addition, subtraction, or bitwise bool glop.  
As for pointer arithmetic -- totally yech!

But I do have a pref'rence, for pointer deref'rence.  
I find NOTS are a bang, and relations a ball.  
I like calling routines, and recursions in essence.   
But the thing I like MOST is a string dot h CALL!

With mem copy I copy, and mem set I clear.   
Take string len of this, and string copy that.  
From my keyboard I pause, to hear subroutines dear:   
The bark of string chrr, and the purr of string CAT!

One tiny detail that could lead to defeat.  
From where an arg points: string calls only go forth,  
So how to go back, to be Turing complete?  
From standard dot H, to the rescue, q SORT!

My fixation might hint at a textual bent.          
Does my program compose a tattoo for your shin?     
Play crosswords or translate from Urdu to Tzouby?  
To give it a whirl, just punch 2 + 2 in.

You can add, do division, and multiply too.  
Take unary minus and also subtract.  
Summing hairs of a walrus?  No longer a fuss.  
Parenthetical grouping -- no pushing a stack!

Try dividing a [googol](https://en.wikipedia.org/wiki/Googol) by one forty three,    
Subtract an [octillion](https://en.wikipedia.org/wiki/Names_of_large_numbers) - it's simply divine.  
To compute a remainder, inscribe a percent.  
For the sign of the answer, see C ninety nine!

A hundred and twenty five digits or so,  
Are the lengthiest figures the program can gnash.  
Go over that limit, by even a digit:     
Risk incorrect answers, or witness a crash!

Say, say, does it have octal or binary zen?  
What about duodecimal, ternary, hex?         
Try the base as an option (of course in base ten)  
Any base two to twenty -- for that is the specs.

Use lowercase in trans-decimal radix,               
Divide *babbage* (in base seventeen) by *cafe* --   
a nice *fad*, but avoid a division by nix:          
No errant result, but you could wait all day!

To grok the internals, ask [Queen Cleopatra](https://en.wikipedia.org/wiki/Cleopatra),  
or [King Tutankhamun](https://en.wikipedia.org/wiki/Tutankhamun); for him it's a romp.    
Addition by cats, and if given two figures,  
to tell which is bigger, sort down and string CMP!

Unlawful subtraction, a grade school infraction,   
starts at the left and works to the right.    
Yet more innovation: like [Henry Ford's cars](https://en.wikipedia.org/wiki/Ford_Motor_Company),  
With a pound and define, mass production of vars!

The moral is clear, for programmers out there:   
With the C lib for strings, you can hack with a flair.

## Copyright and CC BY-SA 4.0 License:

This file is Copyright (c) 2023 by Landon Curt Noll.  All Rights Reserved.
You are free to share and adapt this file under the terms of this license:

    Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)

For more information, see: https://creativecommons.org/licenses/by-sa/4.0/
